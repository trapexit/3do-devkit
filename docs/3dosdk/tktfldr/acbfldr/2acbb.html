<TITLE>Multiply by a constant</TITLE>
<H1><LINK NAME="XREF38728">Multiply by a constant</LINK></H1><HR>
<H2>About this recipe</H2>
This recipe shows you how to construct a sequence of ARM instructions to 
multiply by a constant.<P>
For some applications multiply is used extensively, so it is important to 
make the application run as fast as possible.  For instance, most DSP 
(Digital Signal Processing) applications perform a lot of 
multiplication.<P>
In many cases where a multiply is used, one of the values is a constant 
(eg. weeks*7).  A naive programmer would assume that the only way to 
calculate this would be to use the MUL instruction - but there is an 
alternative...<P>
This recipe demonstrates how to improve the speed of multiply-by-constant 
by using a sequence of arithmetic instructions instead of the 
general-purpose multiplier.<P>
<H2>Introduction</H2>
Throughout this recipe, registers are referred to using register names 
(eg. Rd, Rm, Rs), but you should use only register names which have been 
declared using the RN directive (eg. a1, r4 etc.) in assembler source 
code.  This recipe does not refer to any example programs; it should be 
viewed as an explanation of the multiply-by-constant technique.<P>
MUL has the following syntax:<P>
<CODE>
<PRE>
MUL    Rd, Rm, Rs
</CODE>
</PRE>
The timing of this instruction depends on the value in Rs.  The ARM6 
datasheet specifies that for Rs between 2^(2m-3) and 2^(2m-1)-1 inclusive 
takes 1S + mI cycles.  For more details on the multiplier, see <A 
HREF="./2acbe.html#XREF40554">ARM6 multiplier performance issues</A>.  
There is, of course, no guarantee that MUL will not be implemented 
differently (possibly faster) in the future...<P>
When multiplying by a constant value, it is possible to replace the 
general multiply with a fixed sequence of adds and subtracts which have 
the same effect.  For instance, multiply by 5 could be achieved using a 
single instruction:<P>
<CODE>
<PRE>
ADD    Rd, Rm, Rm, LSL #2                 ; Rd = Rm + (Rm * 4) = Rm * 5
</CODE>
</PRE>
This ADD version is obviously better than the MUL version below:<P>
<CODE>
<PRE>
    MOV    Rs, #5
    MUL    Rd, Rm, Rs
</CODE>
</PRE>
The 'cost' of the general multiply includes the instructions needed to 
load the constant into a register (up to 4 may be needed, or an LDR from a 
literal  pool) as well as the multiply itself.<P>
<H2>The problem of finding the optimum sequence</H2>
The difficulty in using a sequence of arithmetic instructions is that the 
constant must be decomposed into a set of operations which can be done by 
one instruction each.  Consider multiply by 105:<P>
This could be achieved by decomposing thus:<P>
<CODE>
<PRE>
    105 == 128 - 13
        == 128 - 16 + 3
        == 128 - 16 + 2 + 1

    ADD    Rd, Rm, Rm, LSL #1                        ; Rd = Rm*3
    SUB    Rd, Rd, Rm, LSL #4                        ; Rd = Rm*3 - Rm*16
    ADD    Rd, Rd, Rm, LSL #7                        ; Rd = Rm*3 - Rm*16 + Rm*128
</CODE>
</PRE>
Or, decomposing differently:<P>
<CODE>
<PRE>
    105 == 15 * 7
        == (16 - 1) * (8 - 1)

    RSB    Rt, Rm, Rm, LSL #4                        ; Rt = Rm*15 (tmp reg)
    RSB    Rd, Rt, Rt, LSL #3                        ; Rd = Rt*7 = Rm*105
</CODE>
</PRE>
The second method is the optimal solution (fairly easy to find for small 
values such as 105).  However, the problem of finding the optimum becomes 
much  more difficult for larger constant values.  A program can be written 
to search exhaustively for the optimum, but it may take a long time to 
execute.  There are no known algorithms which solve this problem 
quickly.<P>
Temporary registers can be used to store intermediate results to help 
achieve the shortest sequence.  For a large constant, more than one 
temporary may be needed, otherwise the sequence will be longer.<P>
The C-compiler restricts the amount of searching it performs in order to 
minimise the impact on compilation time.  The current version of armcc has 
a cut-off so that it uses a normal MUL if the number of instructions used 
in the multiply-by-constant sequence exceeds some number N.  This is to 
avoid the sequence becoming too long.<P>
<H2>Experimenting with armcc assembly output</H2>
When writing a speed-critical ARM assembler program, it is a good idea to 
code it in C first (to check the algorithm) before converting it to hand 
tuned assembler.  It is helpful to see the ARM code which the compiler 
generates as a starting point for your work.<P>
Invoking <B>armcc</B> with the -S  flag will generate an assembly file 
instead of an object file.  For example, consider the following simple C 
code:<P>
<CODE>
<PRE>
int mulby105( int num )
{
    return num * 105;
}
</CODE>
</PRE>
Compile this using:<P>
<CODE>
<PRE>
armcc -li -S mulby105.c
</CODE>
</PRE>
Now, examine the file <B>mulby105.s</B> which has been created:<P>
<CODE>
<PRE>
; generated by Norcroft ARM C vsn 4.41 (Advanced RISC Machines)
    AREA |C$$code|, CODE, READONLY
|x$codeseg|

    EXPORT  mulby105
mulby105
    RSB    a1,a1,a1,LSL #4
    RSB    a1,a1,a1,LSL #3
    MOV    pc,lr

    AREA |C$$data|,DATA

|x$dataseg|

    END
</CODE>
</PRE>
Notice that the compiler has found the short multiply-by-constant 
sequence.<P>
<H2>Discussion of speed improvement</H2>
To evaluate the speed gains from using multiply-by-constant, consider 
multiplying by 11585 (which is 8192*sqr2) as an example:<P>
A normal multiply consists of:<P>
<CODE>
<PRE>
    MOV    Rs, #0x2D &lt;&lt; 8                       ; load constant
    ORR    Rs, Rs, #0x41                        ; load constant, now Rs = 11585
    MUL    Rd, Rm, Rs                           ; do the multiply
</CODE>
</PRE>
The load-a-constant stage may take up to four 4 instructions (in this case 
2) or an LDR,= and the multiply takes 1 instruction fetch plus a number of 
internal cycles to calculate the multiply (on ARM6 based processors) .<P>
The optimal multiply-by-constant sequence consists of:<P>
<CODE>
<PRE>
    ADD    Rd, Rm, Rm, LSL #1                        ; Rd = Rm*3
    RSB    Rd, Rd, Rd, LSL #4                        ; Rd = Rd*15 = Rm*45
    ADD    Rd, Rm, Rd, LSL #8                        ; Rd = Rm + Rd*256 = Rm*11521
    ADD    Rd, Rd, Rm, LSL #6                        ; Rd = Rd + Rm*64 = Rm*11585
</CODE>
</PRE>
This is just 4 data processing instructions.<P>
<PRE>
-----------------------------------------------------
Method               |Cycles                         
-----------------------------------------------------
Normal multiply      |3 instructions + MUL internal  
                     |cycles                         
-----------------------------------------------------
Multiply-by-constant |4 instructions                 
-----------------------------------------------------
</PRE>
<P>
Considering the ARM6 family, the 2-bit Booth's Multiplier used by MUL 
takes a number of I-cycles depending on the value in Rs (in this case m=8, 
as Rs lies  between 8192 and 32767).<P>
Hence multiply-by-constant looks to be the winner in this case.<P>
An instruction fetch is an external memory S-cycle on the ARM60, or a 
cache F-cycle (if there is a cache hit) on cached processors like the 
ARM610.<P>
With slow memory systems and non-cached processors, I-cycles can be much 
faster  than other cycles because they are internal to the ARM core.  This 
means that  the general multiply can sometimes be the fastest option (for 
large constants where an efficient solution cannot be found)- it should 
also use less memory. If the load-a-constant stage could be moved outside 
a loop, the balance would tip further in favour of the general multiply as 
there is only the MUL to execute.<P>
<PRE>
----------------------------------------------------------
Method           |Cycles on ARM60|Cycles on ARM610        
----------------------------------------------------------
Normal multiply  |3S + 8I        |11F                     
----------------------------------------------------------
Multiply-by-const|4S             |4F                      
ant              |               |                        
----------------------------------------------------------
</PRE>
<P>
<H2>Related topics</H2>

<UL>
<LI><A HREF="./2acbe.html#XREF29872">Digital signal processing on the 
ARM</A>;
<LI><A HREF="./2acbe.html#XREF40554">ARM6 multiplier performance 
issues</A>;
<LI><A HREF="./3acbb.html#XREF41890">Multiplication - Returning a 64-bit 
result</A>;
<LI><A HREF="./2acbk.html#XREF12134">ARM assembly programming performance 
issues</A>.
</UL>
