<TITLE>C Programming for deeply embedded applications</TITLE>
<H1><LINK NAME="XREF10783">C Programming for deeply embedded 
</LINK>applications</H1><HR>
<H2>About this recipe</H2>
In this recipe you will learn about the standalone runtime support system 
for C programming in deeply embedded applications.  In particular you will 
discover:<P>
<UL>
<LI>what <B>rtstand.s</B> supports;
<LI>how to make use of it by looking at example programs;
<LI>how to extend it by adding extra fuctionality from the C library;
<LI>the size of the standalone run time library;
</UL>
<H2>Introduction</H2>
The semi hosted ANSI C library provides all the standard C library 
facilities (and thus is quite large).  This is acceptable when running  
under emulation with plenty of memory available, or maybe even when 
running on development hardware with access to a real debugging channel 
and plenty of memory. However, in a deeply embedded application many of 
the facilities of the C library may no longer be relevent, eg. file access 
functions, time and date functions, and the size of the semi hosted ANSI C 
library may be prohibitive if the memory available is severely limited.<P>
For deeply embedded applications a minimal C runtime system is needed 
which takes up as little memory as possible, is easily portable to the 
target hardware, and only supports those functions required for such an 
application.<P>
The ARM Software Development Toolkit comes with a minimal runtime system 
in source form.  The 'behind the scenes' jobs which it performs are:<P>
<UL>
<LI>setting up the initial stack and heap, and calling main;
<LI>program termination - either automatic (returning from main() or 
forced - explicitly calling __rt_exit);
<LI>simple heap allocation (__rt_alloc);
<LI>stack limit checking;
<LI>setjmp and longjmp support;
<LI>divide and remainder functions (calls to which can be generated by 
<B>armcc</B>);
<LI>high level error handler support (__err_handler);
<LI>optional floating point support, and a means to detect whether 
floating point support is available or not (__rt_fpavailable); 
</UL>
The source code <B>rtstand.s</B> documents the options which you may want 
to change for your target.  These are not covered in this recipe.  The 
header file <B>rtstand.h</B> documents the functions which 
<B>rtstand.s</B> provides to the C programmer.<P>
Note that no support is provided for outputting data down the debugging 
channel.  This can be done, but is specific to the target application.  
The example C programs described below use the ARM Debug Monitor available 
under <B>armsd</B> to output messages using in-line SWIs. <P>
<H2>Using the standalone runtime system</H2>
In this section the main features of the standalone runtime system are 
demonstrated by example programs.<P>
Before attempting any of the demonstrations below create a working 
directory, and set this up as your current directory.  Copy the contents 
of the <B>clstand</B> directory into your working directory, and also copy 
the files <B>fpe*.o</B> from the <B>fpe340</B> directory of the <B>cl</B> 
directory into your working directory.  You are now ready to experiment 
with the C standalone runtime system.<P>
In the examples below, the following options are passed to <B>armcc</B>, 
<B>armasm</B>, and in the first case <B>armsd</B>:<P>
<PRE>
--------------------------------------------------------
Option          |Description                            
--------------------------------------------------------
-li             |Specifies that the the target is a     
                |little endian ARM.                     
--------------------------------------------------------
-apcs 3/32bit   |This specifies that the 32 bit variant 
                |of APCS 3 should be used.  For armasm  
                |this is used to set the built in       
                |variable {CONFIG} to 32.               
--------------------------------------------------------
</PRE>
<P>
These arguments can be changed if the target hardware differs from this 
configuration.  If the ARM Software Tools have been configured as desired 
then these options may be omitted, as the tools will default to the 
configuration time values.<P>
These demonstrations are likely to be most useful if the sources 
<B>rtstand.s</B>, <B>errtest.c</B> and <B>memtest.c</B> are studied in 
conjunction with this recipe.<P>
<H2>A simple program</H2>
Let us compile the example program <B>errtest.c</B>, and assemble the 
standalone runtime system.  These can then be linked together to provide 
an executable image, <B>errtest</B>:<P>
<CODE>
<PRE>
armcc -c errtest.c -li -apcs 3/32bit
armasm rtstand.s -o rtstand.o -li -apcs 3/32bit
armlink -o errtest errtest.o rtstand.o
</CODE>
</PRE>
We can then execute this image under the <B>armsd</B> as follows:<P>
<CODE>
<PRE>
&gt; armsd -li errtest
A.R.M. Source-level Debugger, version 4.10 (A.R.M.) [Aug 26 1992]
ARMulator V1.20, 512 Kb RAM, MMU present, Demon 1.01, FPE, Little 
endian.
Object program file errtest
armsd: go
(the floating point instruction-set is not available)
Using integer arithmetic ...
10000 / 0X0000000A = 0X000003E8
10000 / 0X00000009 = 0X00000457
10000 / 0X00000008 = 0X000004E2
10000 / 0X00000007 = 0X00000594
10000 / 0X00000006 = 0X00000682
10000 / 0X00000005 = 0X000007D0
10000 / 0X00000004 = 0X000009C4
10000 / 0X00000003 = 0X00000D05
10000 / 0X00000002 = 0X00001388
10000 / 0X00000001 = 0X00002710
Program terminated normally at PC = 0x00008550
      0x00008550: 0xef000011 .... : &gt;  swi     0x11
armsd: quit
Quitting
&gt; 
</CODE>
</PRE>
The '&gt;' prompt is the Operating System prompt, and the 'armsd:' prompt 
is output by <B>armsd</B> to indicate that user input is required.<P>
Already several of the standalone runtime system's facilities have been 
demonstrated:<P>
<UL>
<LI>the C stack and heap have been set up;
<LI><B>main</B> has clearly been called;
<LI>the fact that floating point support is not available has been 
detected;
<LI>the integer division functions  have been used by the compiler.
<LI>program termination was successful.
</UL>
<H2>Error handling</H2>
The same program, <B>errtest</B>, can also be used to demonstrate error 
handling, by recompiling <B>errtest.c</B> and predefining the DIVIDE_ERROR 
macro:<P>
<CODE>
<PRE>
armcc -c errtest.c -li -apcs 3/32bit -DDIVIDE_ERROR
armlink -o errtest errtest.o rtstand.o
</CODE>
</PRE>
Again, we can now execute this image under the <B>armsd</B> as follows:<P>
<CODE>
<PRE>
&gt; armsd -li errtest
A.R.M. Source-level Debugger, version 4.10 (A.R.M.) [Aug 26 1992]
ARMulator V1.20, 512 Kb RAM, MMU present, Demon 1.01, FPE, Little 
endian.
Object program file errtest
armsd: go
(the floating point instruction-set is not available)
Using integer arithmetic ...
10000 / 0X0000000A = 0X000003E8
10000 / 0X00000009 = 0X00000457
10000 / 0X00000008 = 0X000004E2
10000 / 0X00000007 = 0X00000594
10000 / 0X00000006 = 0X00000682
10000 / 0X00000005 = 0X000007D0
10000 / 0X00000004 = 0X000009C4
10000 / 0X00000003 = 0X00000D05
10000 / 0X00000002 = 0X00001388
10000 / 0X00000001 = 0X00002710
10000 / 0X00000000 = errhandler called: code = 0X00000001: divide by 0
caller's pc = 0X00008304
returning...

run time error: divide by 0
program terminated

Program terminated normally at PC = 0x0000854c
      0x0000854c: 0xef000011 .... : &gt;  swi     0x11
armsd: quit
Quitting
&gt; 
</CODE>
</PRE>
This time an integer division by zero has been detected by the standalone 
runtime system, which called <B>__err_handler</B>.  <B>__err_hander</B> 
output the first set of error messages in the above output.  Control was 
then returned to the runtime system which output the second set of error 
messages and terminated execution.<P>
<A NAME="XREF40279"><H2>longjmp and setjmp</A></H2>
A further demonstration can be made using <B>errtest</B> by predefining 
the macro LONGJMP to perform a <B>longjmp</B> out of <B>__err_handler</B> 
back into the user program, thus catching and dealing with the error.  
First recompile and link <B>errtest</B>:<P>
<CODE>
<PRE>
armcc -c errtest.c -li -apcs 3/32bit -DDIVIDE_ERROR -DLONGJMP
armlink -o errtest errtest.o rtstand.o
</CODE>
</PRE>
Then rerun <B>errtest</B> under <B>armsd</B>.  We expect the integer 
divide by zero to occur once again:<P>
<CODE>
<PRE>
&gt; armsd -li errtest
A.R.M. Source-level Debugger, version 4.10 (A.R.M.) [Aug 26 1992]
ARMulator V1.20, 512 Kb RAM, MMU present, Demon 1.01, FPE, Little 
endian.
Object program file errtest
armsd: go
(the floating point instruction-set is not available)
Using integer arithmetic ...
10000 / 0X0000000A = 0X000003E8
10000 / 0X00000009 = 0X00000457
10000 / 0X00000008 = 0X000004E2
10000 / 0X00000007 = 0X00000594
10000 / 0X00000006 = 0X00000682
10000 / 0X00000005 = 0X000007D0
10000 / 0X00000004 = 0X000009C4
10000 / 0X00000003 = 0X00000D05
10000 / 0X00000002 = 0X00001388
10000 / 0X00000001 = 0X00002710
10000 / 0X00000000 = errhandler called: code = 0X00000001: divide by 0
caller's pc = 0X00008310
returning...

Returning from __err_handler() with errnum = 0X00000001

Program terminated normally at PC = 0x00008558
      0x00008558: 0xef000011 .... : &gt;  swi     0x11
armsd: quit
Quitting
&gt; 
</CODE>
</PRE>
The runtime system detected the integer divide by zero, and as before 
__err_handler was called, which produced the error messages.  However, 
this time __err_handler used longjmp to return control to the program, 
rather than the runtime system.<P>
<H2>Floating point support</H2>
Using <B>errtest</B> we can also demonstrate floating point support.  You 
should already have copied the appropriate floating point emulator object 
code into your working directory.  For the configuration used in this 
example <B>fpe_32l.o</B> is the correct object file.<P>
However, in addition to this it is also necessary to link with an fpe 
<B>stub</B>, which we must compile from the source given 
(<B>fpestub.s</B>).<P>
<CODE>
<PRE>
armasm fpestub.s -o fpestub.o -li -apcs 3/32bit
armlink -o errtest errtest.o rtstand.o fpestub.o fpe_32l.o -d
</CODE>
</PRE>
The resulting executable, <B>errtest</B>, can be run under <B>armsd</B> as 
before:<P>
<CODE>
<PRE>
&gt; armsd -li errtest
A.R.M. Source-level Debugger, version 4.10 (A.R.M.) [Aug 26 1992]
ARMulator V1.20, 512 Kb RAM, MMU present, Demon 1.01, FPE, Little 
endian.
Object program file errtest
armsd: go
(the floating point instruction-set is available)
Using Floating point, but casting to int ...
10000 / 0X0000000A = 0X000003E8
10000 / 0X00000009 = 0X00000457
10000 / 0X00000008 = 0X000004E2
10000 / 0X00000007 = 0X00000594
10000 / 0X00000006 = 0X00000682
10000 / 0X00000005 = 0X000007D0
10000 / 0X00000004 = 0X000009C4
10000 / 0X00000003 = 0X00000D05
10000 / 0X00000002 = 0X00001388
10000 / 0X00000001 = 0X00002710
10000 / 0X00000000 = errhandler called: code = 0X80000202: Floating 
Point
Exception : Divide By Zero

caller's pc = 0XE92DE000
returning...

Returning from __err_handler() with errnum = 0X80000202

Program terminated normally at PC = 0x00008558 (__rt_exit + 0x10)
+0010 0x00008558: 0xef000011 .... : &gt;  swi     0x11
armsd: quit
Quitting
&gt; 
</CODE>
</PRE>
This time the floating point instruction set is found to be available, and 
when a floating point division by zero is attempted, <B>__err_handler</B> 
is called with the details of the floating point divide by zero 
exception.<P>
Note that if you have compiled <B>errtest.c</B> other than as in <A 
HREF="#XREF40279">longjmp and setjmp</A>, you will not see precisely this 
dialogue with <B>armsd</B>.<P>
<H2>Running out of heap</H2>
A second example program, <B>memtest.c</B> demonstrates how the standalone 
runtime system copes with allocating stack space, and also demonstrates 
the simple memory allocation function <B>__rt_alloc</B>.  Let us first 
compile this program so that it should repeatedly request more memory, 
until there is none left:<P>
<CODE>
<PRE>
armcc -li -apcs 3/32bit memtest.c -c
armlink -o memtest memtest.o rtstand.o
</CODE>
</PRE>
This can be run under <B>armsd</B> in the usual way:<P>
<CODE>
<PRE>
&gt; armsd -li memtest
A.R.M. Source-level Debugger, version 4.10 (A.R.M.) [Aug 26 1992]
ARMulator V1.20, 512 Kb RAM, MMU present, Demon 1.01, FPE, Little 
endian.
Object program file memtest
armsd: go
kernel memory management test
force stack to 4KB
request 0 words of heap - allocate 256 words at 0X000085A0
force stack to 8KB
..
force stack to 60KB
request 33211 words of heap - allocate 33211 words at 0X00049388
force stack to 64KB
request 49816 words of heap - allocate 5739 words at 0X00069A74
memory exhausted, 105376 words of heap, 64KB of stack
Program terminated normally at PC = 0x0000847c
      0x0000847c: 0xef000011 .... : &gt;  swi     0x11
armsd: quit
Quitting
&gt; 
</CODE>
</PRE>
This demonstrates that allocating space on the stack is working correctly, 
and also that the <B>__rt_alloc</B> routine is working as expected.  The 
program terminated because in the end <B>__rt_alloc</B> could not allocate 
the requested amount of memory.<P>
<A NAME="XREF38409"><H2>Stack overflow checking</A></H2>
<B>memtest</B> can also be used to demonstrate stack overflow checking by 
recompiling with the macro STACK_OVERFLOW defined.  In this case the 
amount of stack required is increased until there is not enough stack 
available, and stack overflow detection causes the program to be 
aborted.<P>
To recompile and link <B>memtest.c</B> issue the following commands:<P>
<CODE>
<PRE>
armcc -li -apcs 3/32bit memtest.c -c -DSTACK_OVERFLOW
armlink -o memtest memtest.o rtstand.o
</CODE>
</PRE>
Running this program under <B>armsd</B> produces the following output:<P>
<CODE>
<PRE>
&gt; armsd -li memtest
A.R.M. Source-level Debugger, version 4.10 (A.R.M.) [Aug 26 1992]
ARMulator V1.20, 512 Kb RAM, MMU present, Demon 1.01, FPE, Little 
endian.
Object program file memtest
armsd: go
kernel memory management test
force stack to 4KB
...
force stack to 256KB
request 1296 words of heap - allocate 1296 words at 0X0000AE20
force stack to 512KB

run time error: stack overflow
program terminated

Program terminated normally at PC = 0x0000847c
      0x0000847c: 0xef000011 .... : &gt;  swi     0x11
armsd: quit
Quitting
&gt; 
</CODE>
</PRE>
Clearly stack overlfow checking did indeed catch the case where too much 
stack was required, and caused the runtime system to terminate the program 
after giving an appropriate diagnostic.<P>
<H2>Extending the standalone runtime system</H2>
For a many applications it may be desirable to have access to more of the 
standard C library than just the minimal runtime system provides.  This 
section demonstrates how to take out a part of the standard C library and 
plug it into the standalone runtime system.<P>
The function which we will add to <B>rtstand</B> is <B>memmove</B>.  
Although this is small, and easily extracted from the C library source, 
the same methodology can be applied to larger sections of the C library, 
eg. the dynamic memory allocation system (malloc, free, etc).<P>
The source of the C library can be found in the <B>cl</B> directory.  The 
source for the <B>memmove</B> function is in <B>string.c</B>.  The 
extracted source for <B>memmove</B> has been put into <B>memmove.c</B>, 
and the compile time option <B>_copywords</B> has been removed.  The 
function declaration for <B>memmove</B> and a typedef for <B>size_t</B> 
(extracted from <B>include/stddef.h</B>) have been put into 
<B>memmove.h</B>.<P>
Our memmove module can be compiled as follows.<P>
<CODE>
<PRE>
armcc -c memmove.c -li -apcs 3/32bit
</CODE>
</PRE>
The output, <B>memmove.o</B> can be linkedwith the user's other object 
modules together with rtstand.o in the normal way (see previous examples 
in this section).<P>
<H2>The size of the standalone runtime library</H2>
<B>rtstand.s</B> has been separated into several code Areas.  The 
advantage of this is that <B>armlink</B> can detect if any Areas are 
unreferenced, and then eliminate them from the output image.<P>
The table below shows the typical size of the Areas in <B>rtstand.o</B>:<P>
<PRE>
---------------------------------------------------------
Area                 |Size   |Functions                  
                     |(bytes)|                           
---------------------------------------------------------
C$$data              |4      |                           
---------------------------------------------------------
C$$code$$__main      |96     |__main, __rt_exit          
---------------------------------------------------------
C$$code$$__rt_fpavail|8      |__rt_fpavailable           
able                 |       |                           
---------------------------------------------------------
C$$code$$__rt_trap   |128    |__rt_trap                  
---------------------------------------------------------
C$$code$$__rt_alloc  |68     |__rt_alloc                 
---------------------------------------------------------
C$$code$$__rt_stkovf |76     |__rt_stkovf_split_*        
---------------------------------------------------------
C$$code$$__jmp       |100    |longjmp, setjmp            
---------------------------------------------------------
C$$code$$__divide    |256    |__rt_sdiv, __rt_udiv,      
                     |       |__rt_udiv10,               
---------------------------------------------------------
All Areas            |736    |__rt_sdiv10, __rt_divtest  
---------------------------------------------------------
</PRE>
<P>
If floating point support is definitely not required, then the 
EnsureNoFPSupport variable can be set to {TRUE}, and some extra space will 
be saved.  After making any modifications to <B>rtstand.s</B>, the size of 
the various areas can be found by using the command:<P>
<CODE>
<PRE>
decaof -b rtstand.o
</CODE>
</PRE>
From the above table it is clear that for many applications the standalone 
runtime library will be roughly 0.5Kb.<P>
<H2>Related topics</H2>

<UL>
<LI><A HREF="./3acba.html#XREF36909">Register usage under the ARM 
procedure call standard</A>;
<LI><A HREF="./3acbc.html#XREF35534">In-Line SWIs</A>.
</UL>
