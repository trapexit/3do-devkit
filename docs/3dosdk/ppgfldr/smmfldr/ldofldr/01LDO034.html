<Title>ChainCelsAtHead </Title>
<A NAME="XREF31485"><H1>ChainCelsAtHead </A></H1>
 Chains together lists of cels.<P>
<H3>Synopsis</H3>
<CODE>CCB * ChainCelsAtHead (CCB *existingCels, CCB *newCels)</CODE><P>
<H3>Description</H3>
Chains together two lists of cels, putting the new list ahead of the existing cels. The return value is a pointer to the first cel in the resulting list. Either pointer can be NULL, eliminating the need for special-case code when iteratively building a list of cels. <P>
For example, the following code will work: <P>
<CODE>
<PRE>
CCB *list = NULL; 
CCB *cels; 
do {     cels = get_next_antialiased_cel(); 
    list = ChainCelsAtHead(list, cels); } 
while (cels != NULL); 
</CODE>
</PRE>
This function works properly with anti-aliased cels and similar constructs where a list of related cels makes up a single logical entity. <P>
<H3>Arguments</H3>
<DL>
<DT>existingCels
<DD>Pointer to the existing list of cels; may be NULL. 
</DL>
<DL>
<DT>newCels
<DD>Pointer to the new list of cels to be added ahead of the existing list; may be NULL. 
</DL>
<H3>Return Value</H3>
Pointer to the head of the resulting list of cels. <P>
<H3>Implementation</H3>
Library call implemented in lib3do.lib. <P>
<H3>Associated Files</H3>
lib3do.lib, celutils.h<P>
<H3>See Also</H3>
<CODE><A HREF="./01LDO035.html#XREF15053"><CODE>ChainCelsAtTail</A> </CODE><P>
</CODE>