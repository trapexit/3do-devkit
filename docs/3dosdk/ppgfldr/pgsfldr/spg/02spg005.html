<TITLE>Loading and Executing Separate Code Modules</TITLE>
<H1><LINK NAME="XREF16033">Loading and Executing Separate Code Modules</LINK></H1><HR>
Using the <CODE>LoadProgram()</CODE> and <CODE>LoadProgramPrio()</CODE> calls mentioned previously, you can load an executable file from external storage, and launch it as a totally independent task. This gives the code its own memory pages and resource tracking. It also means that even if the program being loaded is only 4 KB big, it will still consume an entire page of RAM, which is normally 32 KB or 16 KB. Loading such programs can waste a lot of memory if you launch many of them.<P>
Instead of launching separate tasks, it is generally better for an application to launch separate threads. As described above, you can use <CODE>CreateThread()</CODE> to do this with functions that are within your program.<P>
In many cases, it is desirable to split up a program into multiple pieces, only one of which needs to be in memory at any given time. For example, the code to control the high score table of your game doesn't need to reside in memory when playing the game. It only needs to be loaded when the time comes to display the high score table.<P>
Portfolio supports the partitioning of a game into multiple executable files with the <CODE>LoadCode()</CODE> function. Using <CODE>LoadCode()</CODE>, you can load the data for an executable file in memory, and then launch the code as a thread using <CODE>ExecuteAsThread()</CODE> or <CODE>ExecuteAsSubroutine()</CODE>. Once you finish with the code module, you can unload it from memory using the <CODE>UnloadCode()</CODE> function.<P>
<CODE>LoadCode()</CODE> is defined as:<P>
<DL>
<DD><CODE>Err LoadCode( char *fileName, CodeHandle *code )</CODE><BR>
</DL>
The <CODE>fileName</CODE> argument specifies the name of the executable file to load. This is a regular executable file as generated by the ARM linker, except that it must be linked with different startup code. If you plan on executing this file as a thread, then you must link the file with <I>threadstartup.o</I><CODE> </CODE>instead of <I>cstartup.o</I>. If you plan on executing the file as a subroutine, it must be linked with <I>subroutinestartup.o</I>. The code argument is a pointer to a variable where a handle to the loaded code is stored.<P>
<CODE>LoadCode()</CODE> reads the file and allocates memory to hold its contents. The allocated memory is within the address space of the current task. If the current task exits, the memory is automatically freed.<P>
Once code has been loaded, it can be executed using either <CODE>ExecuteAsThread()</CODE> or <CODE>ExecuteAsSubroutine().</CODE><P>
<DL>
<DD><CODE>Err ExecuteAsThread( CodeHandle code, uint32 argc, char **argv, char *threadName, int32 priority )<BR>
Err ExecuteAsSubroutine( CodeHandle code, uint32 argc, char **argv )</CODE><BR>
</DL>
The <CODE>code</CODE> argument specifies the loaded code to run. This is the value stored by <CODE>LoadCode()</CODE> in the <CODE>CodeHandle</CODE> variable passed to it. <CODE>argc</CODE> and <CODE>argv</CODE> are two 32-bit values Portfolio does not use, and are just passed through to the code being executed. These are the values that the <CODE>main()</CODE> routine in the loaded code receives for its <CODE>argc</CODE> and <CODE>argv</CODE> parameters. Finally, when executing a thread, you must specify a thread name, and priority, just like when using <CODE>CreateThread()</CODE>.<P>
Once the code completes execution, call <CODE>UnloadCode()</CODE>:<P>
<DL>
<DD><CODE>Err UnloadCode( CodeHandle code )</CODE><BR>
</DL>
This removes the loaded code and frees its memory.<P>
When you load external code and execute it using the above function, it is important to understand that the code is actually a separate executable file. This means that global variables in one code module cannot be accessed by a different code module.<P>
When you execute loaded code as a thread, any memory this thread allocates does not get freed when the thread exits or when the code is unloaded. The thread must clean up after itself, just like a thread created using <CODE>CreateThread()</CODE>.<P>
If loaded code is being executed as a subroutine and calls <CODE>exit()</CODE>, this call causes the entire program, not just the subroutine, to exit.<P>
